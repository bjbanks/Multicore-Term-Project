/*
 * Copyright 2020 Bryson Banks and David Campbell.  All rights reserved.
 */

#ifndef _WSDS_WORKER_DEFINE
#define _WSDS_WORKER_DEFINE

#include <stdlib.h>
#include <thread>
#include "deque.h"

namespace WSDS {

class Task; // forward declaration, defined elsewhere

/*
 * Internal data structures and functions not expected to be used
 * by user applications utilizing the WSDS user-level scheduler.
 */
namespace internal {

class Deque; // forward declaration, defined elsewhere

/*
 * A singular worker of the scheduler which will carry out the computation
 * of scheduled tasks (i.e. "work"). Internally generated by the scheduler,
 * workers will process tasks in their own individual threads. Each worker
 * will have their own "ready" pool of waiting ready tasks, formally stored
 * in a deque data structure. When a worker has no ready tasks in their own
 * pool, they may attempt to steal a ready task from another random worker.
 *
 * The scheduler will consider one of the workers ("worker zero") to be the
 * "master" worker, and only this worker will the scheduler ever manually
 * assign a task to. This will always be a "root" task, which in most cases
 * will spawn many children tasks that will inevitably be "stolen" by the
 * other non-master workers to maximize parallel computation.
 */
class Worker {

public:
    Worker(int id, int nvictims, bool useStealing = true);
    ~Worker();

    // add a "victim" worker to cache of potential victims
    void add_victim(Worker* victim);

    // add a task to the worker's ready pool
    void add_ready_task(Task* task);

    // called by the executing task when a "child" tasks is spawned in order
    // to add the task to the worker's ready pool
    void add_child_task(Task* task);

    // indicate this worker should be stopped
    void stop(void);

    // the main work loop of the worker
    void work_loop(void);

    // secondary work loop for when the task being processed calls a wait()
    // and can not proceed until all its children tasks have finished
    void wait_loop(void);

    // called by the scheduler to assign a "root" task to the master worker
    void assign_root_task(Task* task);

private:
    int id;
    Task* assignedTask;
    Deque* readyDeq;
    int nvictims;
    Deque** victimDeqs;
    std::atomic_bool stopped;
    bool useStealing;

    // attempt to steal a task from a "victim"
    Task* steal_task(void);

#ifdef _UNIT_TESTING
public:
    int get_id() { return this->id; }
    int get_nvictims() { return this->nvictims; }
    bool get_useStealing() { return this->useStealing; }
#endif

}; // class Worker

} // namespace internal

} // namespace WSDS

#endif // _WSDS_WORKER_DEFINE
